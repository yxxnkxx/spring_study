# 객체 지향 쿼리 언어 - JPQL

JPA를 사용하면 엔티티 객체를 중심으로 개발

문제는 검색 쿼리

- 검색을 할 때도 테이블이 아닌 엔티티 객체를 대상으로 검색
- 모든 DB 데이터를 객체로 변환해서 검색하는 것은 불가능

## JPQL

SQL을 추상화한 JPQL이라는 객체 지향 쿼리 언어 제공

엔티티 객체를 대상으로 쿼리

Java Persistence Query Language

엔티티와 속성은 대소문자 구분 O

JPQL 키워드는 대소문자 구분X

엔티티 이름 O, 테이블 이름 X

별칭 필수

### 프로젝션

SELECT 절에 조회할 대상을 지정하는 것

Entity 프로젝션 → 영속성 컨텍스트에 포함

임베디드 타입은 FROM 절에 추가할 수 없음

### 경로 표현식

.(점)을 찍어 객체 그래프를 탐색

```java
select m.username // 상태 필드
	from Member m
		join m.team t // 단일 값 연관 필드
		join m.orders o // 컬렉션 값 연관 필드
where t.name = '팀A'
```

상태 필드: 단순히 값을 저장하기 위한 필드 (m.username)

연관 필드: 연관관계를 위한 필드

- 단일값 연관필드: @ManyToOne, @OneToOne, 대상이 **엔티티**
- 컬렉션값 연관필드: @OneToMany, @ManyToMany, 대상이 **컬렉션**

특징

- 상태 필드: 경로 탐색의 끝
- 단일값 연관경로: 묵시적 내부 조인(inner join) 발생, 탐색 O
- 컬렉션값 연관경로: 묵시적 내부 조인 발생, 탐색 X
    - FROM 절에서 명시적 조인을 통해 별칭을 얻으면 별칭을 통해 탐색 가능

묵시적 내부조인 권장X

### 페치 조인

JPQL에서 성능 최적화를 위해 제공하는 기능

연관된 엔티티나 컬렉션을 SQL 한 번에 조회

inner join

**DISTINCT**

JPQL의 기능

- SQL에 DISTINCT 추가
- 애플리케이션에 엔티티 중복 제거
    - 같은 식별자를 가진 Team 엔티티 제거

일반 조인: 연관된 엔티티를 함께 조회하지 않음

**한계**

- 페치 조인 대상에는 별칭을 줄 수 없다
- 둘 이상의 컬렉션은 페치 조인할 수 없다
- 컬렉션을 페치 조인하면 페이징 API를 사용할 수 없다

페치 조인은 객체 그래프를 유지할 때 사용하면 효과적

→ 여러 테이블을 조인해서 엔티티가 가진 모양이 아닌 전혀 다른 결과를 내야 하면, 페치 조인보다는 일반 조인을 사용하고 필요한 데이터들만 조회해서 DTO로 반환하는 것이 효과적

### 다형성 쿼리

- 조회 대상을 특정 자식으로 한정

TREAT - 자바의 타입 캐스팅과 유사

### Named 쿼리

정적 쿼리

미리 정의해서 이름을 부여해두고 사용하는 JPQL

애플리케이션 로딩 시점에 쿼리를 검증

애플리케이션 로딩 시점에 초기화 후 재사용

### 벌크 연산

- 영속성 컨텍스트를 무시하고 데이터베이스에 직접 쿼리 → 영속성 컨텍스트와 데이터베이스의 데이터가 일치하지 않음

→ 벌크 연산을 먼저 실행, 벌크 연산 수행 후 영속성 컨텍스트 초기화